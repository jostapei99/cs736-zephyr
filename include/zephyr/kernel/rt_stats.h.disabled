/*
 * Copyright (c) 2025 Real-Time Scheduler Statistics
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#ifndef ZEPHYR_INCLUDE_KERNEL_RT_STATS_H_
#define ZEPHYR_INCLUDE_KERNEL_RT_STATS_H_

#include <zephyr/kernel.h>
#include <zephyr/sys/util.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @defgroup rt_stats_apis Real-Time Scheduler Statistics APIs
 * @ingroup kernel_apis
 * @{
 */

#ifdef CONFIG_736_RT_STATS

/**
 * @brief RT scheduler statistics structure (user-facing)
 *
 * This structure contains comprehensive statistics for analyzing
 * real-time thread behavior and scheduler performance.
 */
struct k_thread_rt_stats {
	/* Event counters */
	uint32_t activations;        /**< Number of job releases/activations */
	uint32_t preemptions;        /**< Times preempted by higher priority thread */
	uint32_t context_switches;   /**< Total context switches (scheduled in/out) */
	uint32_t deadline_misses;    /**< Number of deadline violations */
	uint32_t priority_inversions; /**< Times blocked by lower priority thread */

	/* Timing statistics (in milliseconds) */
	uint64_t total_response_time;  /**< Sum of all response times */
	uint64_t total_waiting_time;   /**< Sum of all waiting times (ready→running) */
	uint64_t total_exec_time;      /**< Sum of actual execution times */
	uint32_t min_response_time;    /**< Minimum response time observed */
	uint32_t max_response_time;    /**< Maximum response time observed */
	uint32_t min_waiting_time;     /**< Minimum waiting time observed */
	uint32_t max_waiting_time;     /**< Maximum waiting time observed */

#ifdef CONFIG_736_RT_STATS_SQUARED
	/* Squared sums for variance/jitter calculation */
	uint64_t sum_response_time_sq; /**< Σ(response_time²) for variance */
	uint64_t sum_waiting_time_sq;  /**< Σ(waiting_time²) for variance */
#endif

#ifdef CONFIG_736_RT_STATS_DETAILED
	/* Detailed timestamps (k_uptime_get() units - milliseconds) */
	uint64_t last_activation_time;  /**< Timestamp of last job release */
	uint64_t last_ready_time;       /**< Timestamp when last entered ready queue */
	uint64_t last_start_time;       /**< Timestamp when last dispatched to CPU */
	uint64_t last_completion_time;  /**< Timestamp when last finished execution */
#endif
};

/**
 * @brief Get RT scheduling statistics for a thread
 *
 * Retrieves comprehensive statistics for the specified thread.
 * Only available when CONFIG_736_RT_STATS is enabled.
 *
 * @param thread Thread to query (NULL for current thread)
 * @param stats Pointer to stats structure to fill
 * @return 0 on success, negative error code on failure
 *         -EINVAL if thread or stats is NULL
 *         -ENOTSUP if CONFIG_736_RT_STATS is not enabled
 */
__syscall int k_thread_rt_stats_get(k_tid_t thread, struct k_thread_rt_stats *stats);

/**
 * @brief Reset RT scheduling statistics for a thread
 *
 * Clears all statistics counters for the specified thread.
 *
 * @param thread Thread to reset (NULL for current thread)
 * @return 0 on success, negative error code on failure
 */
__syscall int k_thread_rt_stats_reset(k_tid_t thread);

/**
 * @brief Record a thread activation/release
 *
 * Called when a periodic task releases a new job. Updates
 * activation counter and timestamps.
 *
 * @param thread Thread being activated (NULL for current thread)
 */
__syscall void k_thread_rt_stats_activation(k_tid_t thread);

/**
 * @brief Record a deadline miss
 *
 * Called when a thread misses its deadline. Increments
 * the deadline_misses counter.
 *
 * @param thread Thread that missed deadline (NULL for current thread)
 */
__syscall void k_thread_rt_stats_deadline_miss(k_tid_t thread);

/**
 * @brief Calculate average response time
 *
 * Helper function to compute average response time from statistics.
 *
 * @param stats Statistics structure
 * @return Average response time in milliseconds (0 if no activations)
 */
static inline uint32_t k_thread_rt_stats_avg_response(const struct k_thread_rt_stats *stats)
{
	if (stats->activations == 0) {
		return 0;
	}
	return (uint32_t)(stats->total_response_time / stats->activations);
}

/**
 * @brief Calculate average waiting time
 *
 * Helper function to compute average waiting time from statistics.
 *
 * @param stats Statistics structure
 * @return Average waiting time in milliseconds (0 if no activations)
 */
static inline uint32_t k_thread_rt_stats_avg_waiting(const struct k_thread_rt_stats *stats)
{
	if (stats->activations == 0) {
		return 0;
	}
	return (uint32_t)(stats->total_waiting_time / stats->activations);
}

/**
 * @brief Calculate average execution time
 *
 * Helper function to compute average execution time from statistics.
 *
 * @param stats Statistics structure
 * @return Average execution time in milliseconds (0 if no activations)
 */
static inline uint32_t k_thread_rt_stats_avg_exec(const struct k_thread_rt_stats *stats)
{
	if (stats->activations == 0) {
		return 0;
	}
	return (uint32_t)(stats->total_exec_time / stats->activations);
}

/**
 * @brief Calculate deadline miss ratio
 *
 * Helper function to compute percentage of deadline misses.
 *
 * @param stats Statistics structure
 * @return Deadline miss ratio as percentage (0.0 to 100.0)
 */
static inline float k_thread_rt_stats_miss_ratio(const struct k_thread_rt_stats *stats)
{
	if (stats->activations == 0) {
		return 0.0f;
	}
	return 100.0f * stats->deadline_misses / (float)stats->activations;
}

#ifdef CONFIG_736_RT_STATS_SQUARED
/**
 * @brief Calculate response time variance
 *
 * Computes variance using: Var(X) = E[X²] - E[X]²
 *
 * @param stats Statistics structure
 * @return Response time variance in ms² (0 if insufficient data)
 */
static inline uint64_t k_thread_rt_stats_response_variance(const struct k_thread_rt_stats *stats)
{
	if (stats->activations < 2) {
		return 0;
	}
	
	uint64_t avg = stats->total_response_time / stats->activations;
	uint64_t avg_sq = stats->sum_response_time_sq / stats->activations;
	
	/* Var(X) = E[X²] - E[X]² */
	if (avg_sq >= avg * avg) {
		return avg_sq - (avg * avg);
	}
	return 0;  /* Numerical stability: avoid negative variance */
}

/**
 * @brief Calculate response time standard deviation
 *
 * Computes standard deviation (square root of variance).
 * Approximates sqrt using integer arithmetic.
 *
 * @param stats Statistics structure
 * @return Response time standard deviation in ms (0 if insufficient data)
 */
static inline uint32_t k_thread_rt_stats_response_stddev(const struct k_thread_rt_stats *stats)
{
	uint64_t var = k_thread_rt_stats_response_variance(stats);
	if (var == 0) {
		return 0;
	}
	
	/* Integer square root approximation */
	uint64_t x = var;
	uint64_t y = (x + 1) / 2;
	while (y < x) {
		x = y;
		y = (x + var / x) / 2;
	}
	return (uint32_t)x;
}

/**
 * @brief Calculate response time jitter (max - min)
 *
 * Simple jitter metric based on range.
 *
 * @param stats Statistics structure
 * @return Response time jitter in ms
 */
static inline uint32_t k_thread_rt_stats_response_jitter(const struct k_thread_rt_stats *stats)
{
	if (stats->activations == 0) {
		return 0;
	}
	return stats->max_response_time - stats->min_response_time;
}

/**
 * @brief Calculate waiting time variance
 *
 * Computes variance using: Var(X) = E[X²] - E[X]²
 *
 * @param stats Statistics structure
 * @return Waiting time variance in ms² (0 if insufficient data)
 */
static inline uint64_t k_thread_rt_stats_waiting_variance(const struct k_thread_rt_stats *stats)
{
	if (stats->activations < 2) {
		return 0;
	}
	
	uint64_t avg = stats->total_waiting_time / stats->activations;
	uint64_t avg_sq = stats->sum_waiting_time_sq / stats->activations;
	
	if (avg_sq >= avg * avg) {
		return avg_sq - (avg * avg);
	}
	return 0;
}

/**
 * @brief Calculate waiting time standard deviation
 *
 * @param stats Statistics structure
 * @return Waiting time standard deviation in ms
 */
static inline uint32_t k_thread_rt_stats_waiting_stddev(const struct k_thread_rt_stats *stats)
{
	uint64_t var = k_thread_rt_stats_waiting_variance(stats);
	if (var == 0) {
		return 0;
	}
	
	uint64_t x = var;
	uint64_t y = (x + 1) / 2;
	while (y < x) {
		x = y;
		y = (x + var / x) / 2;
	}
	return (uint32_t)x;
}
#endif /* CONFIG_736_RT_STATS_SQUARED */

#ifdef CONFIG_736_RT_STATS_DETAILED
/**
 * @brief Calculate current response time
 *
 * Response time from last activation to completion.
 *
 * @param stats Statistics structure
 * @return Last response time in ms (0 if no completion yet)
 */
static inline uint32_t k_thread_rt_stats_last_response(const struct k_thread_rt_stats *stats)
{
	if (stats->last_completion_time >= stats->last_activation_time) {
		return (uint32_t)(stats->last_completion_time - stats->last_activation_time);
	}
	return 0;
}

/**
 * @brief Calculate last waiting time
 *
 * Waiting time from ready to running for last activation.
 *
 * @param stats Statistics structure
 * @return Last waiting time in ms
 */
static inline uint32_t k_thread_rt_stats_last_waiting(const struct k_thread_rt_stats *stats)
{
	if (stats->last_start_time >= stats->last_ready_time) {
		return (uint32_t)(stats->last_start_time - stats->last_ready_time);
	}
	return 0;
}

/**
 * @brief Calculate last execution time
 *
 * Actual execution time for last activation.
 *
 * @param stats Statistics structure
 * @return Last execution time in ms
 */
static inline uint32_t k_thread_rt_stats_last_exec(const struct k_thread_rt_stats *stats)
{
	if (stats->last_completion_time >= stats->last_start_time) {
		return (uint32_t)(stats->last_completion_time - stats->last_start_time);
	}
	return 0;
}
#endif /* CONFIG_736_RT_STATS_DETAILED */

#else /* !CONFIG_736_RT_STATS */

/* Stub definitions when stats are disabled */
struct k_thread_rt_stats {
	uint32_t dummy;
};

/* All syscall stubs are auto-generated when CONFIG_736_RT_STATS is not set */

#endif /* CONFIG_736_RT_STATS */

/**
 * @}
 */

#ifdef __cplusplus
}
#endif

#include <zephyr/syscalls/rt_stats.h>

#endif /* ZEPHYR_INCLUDE_KERNEL_RT_STATS_H_ */
